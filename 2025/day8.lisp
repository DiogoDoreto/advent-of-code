(defclass day8/junction (standard-object)
  ((x :accessor day8/x :initarg :x :type number)
   (y :accessor day8/y :initarg :y :type number)
   (z :accessor day8/z :initarg :z :type number)))

(defmethod print-object ((obj day8/junction) stream)
  (print-unreadable-object (obj stream :type t)
    (format stream "~D,~D,~D" (day8/x obj) (day8/y obj) (day8/z obj))))

(defun day8/make-junction (x y z)
  (make-instance 'day8/junction :x x :y y :z z))

(defmethod day8/distance ((j1 day8/junction) (j2 day8/junction))
  (let ((dx (- (day8/x j2) (day8/x j1)))
        (dy (- (day8/y j2) (day8/y j1)))
        (dz (- (day8/z j2) (day8/z j1))))
    (sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))

(defun day8/parse-junctions (filepath)
  (with-open-file (input filepath)
    (loop for line = (read-line input nil)
          while line
          collect (apply #'day8/make-junction (mapcar #'parse-integer (str:split "," line))))))

(defun day8/make-junction-pairs (junctions &optional (max-items 0))
  (let ((pairs '()))
    (do* ((curr (car junctions) (car rest))
          (rest (cdr junctions) (cdr rest)))
         ((null rest) pairs)
      (dolist (other rest)
        (push (cons curr other) pairs)))
    (setf pairs (sort pairs #'< :key (lambda (pair) (day8/distance (car pair) (cdr pair)))))
    (if (> max-items 0)
        (subseq pairs 0 max-items)
        pairs)))

(defun day8/join-circuits (j1 j2 circuits)
  (let* ((c1 (find-if (lambda (c) (find j1 c)) circuits))
         (c2 (find-if (lambda (c) (find j2 c)) circuits)))
    (cond ((and c1 c2 (eql c1 c2)) nil)
          ((and c1 c2) (setf circuits (cons (concatenate 'list c1 c2)
                                            (remove c2 (remove c1 circuits :count 1) :count 1))))
          (c1 (setf circuits (cons (cons j2 c1)
                                   (remove c1 circuits :count 1))))
          (c2 (setf circuits (cons (cons j1 c2)
                                   (remove c2 circuits :count 1))))
          (t (setf circuits (cons (list j1 j2)
                                  circuits)))))
  circuits)


(defun day8/solve-part1 (filepath max-connections)
  (let* ((junctions (day8/parse-junctions filepath))
         (pairs (day8/make-junction-pairs junctions max-connections))
         (circuits '(())))
    (dolist (pair pairs)
      (let* ((j1 (car pair))
             (j2 (cdr pair)))
        (setf circuits (day8/join-circuits j1 j2 circuits))))
    (let* ((clengths (sort (mapcar #'length circuits) #'>)))
      (apply #'* (subseq clengths 0 3)))))

(assert (= 40 (day8/solve-part1 "./day8-input0.txt" 10)))
(assert (= 66640 (day8/solve-part1 "./day8-input1.txt" 1000)))

(defun day8/solve-part2 (filepath)
  (let* ((junctions (day8/parse-junctions filepath))
         (pairs (day8/make-junction-pairs junctions))
         (circuits (mapcar #'list junctions)))
    (dolist (pair pairs)
      (let* ((j1 (car pair))
             (j2 (cdr pair)))
        (setf circuits (day8/join-circuits j1 j2 circuits))
        (when (null (cdr circuits))
          (return (* (day8/x j1) (day8/x j2))))))))

(assert (= 25272 (day8/solve-part2 "./day8-input0.txt")))
(assert (= 78894156 (day8/solve-part2 "./day8-input1.txt")))
